\title: 最速输入问题 (中)
\date: 2017-10-13 11:54:27
\tags: Combinatorics

---
好的, 继续拓展这个问题, 现在加入鼠标

规定以下四种为基本操作.

  1. 用键盘打出一个字母
  2. 选定 任意长度的一串字母
  3. 复制 选定的一串字母到粘贴板中
  4. 粘贴 粘贴板中的一串字母

<!--more-->

还是递归, 不过这次是二维的了.

 

$$S(i, j) = \min_{0\leq k<j}[S(i,k)+2), S(i-j, j)+1, S(i-1,j)+1]$$

第一项表示更新剪贴板的内容，需要选择和复制两次操作;

第二项表示剪贴板有j个1，现已打出i - j个数，粘贴一次后一共打出i个数;

第三项表示剪贴板有j个1，现已打出i - 1个数，再次输入一次1后一共打出i个数。

然后选出最大的.

$$S(n) = \min_{0\leq k\leq j}S(i,j)\quad \mathtt{where}\ i\geq j \geq 0$$

 

 

<div>
  <div>
    <p>
      其实这个问题可以有另外的理解方式。。。我们把所有的A替换成‘) * ('，把所有的1, C, V替换成+1，然后你会发现这个东西变成了一个连乘积的形式，我们知道所有项一样大的时候乘积最大，那么就变成了，（a+1)*b是定值，求a^b的最大值的问题。。。
    </p>
    
    <p>
      我们把b=n/(a+1)带入，形式是，(a^(1/(a+1)))^n，我们知道n是定值，所以就是a^(1/(a+1))的极值点的问题。。。对正整数a来说答案是4。。。
    </p>
  </div>
  
  <p>
    作者：yw662<br /> 链接：https://www.zhihu.com/question/265201139/answer/290715406<br /> 来源：知乎<br /> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  </p>
</div>

 

 

 

---

现在允许加入删除, 问题会有什么变化呢?

递推不能用了, 无法比较 $\mathtt{dp[i-1]+1,dp[i],dp[i+1]}$, 递推哪能往上比较...

那就只能用图编程了.

<div>
  符合条件的的有以下三种原子操作:
</div>

  1. 输入当然是从i-1输入, 代价 \mathtt{E}
  2. 删除当然是从i+1删除, 代价 \mathtt{D}
  3. 翻n倍,全选+粘贴, 代价 \mathtt{S+n V}

<div>
  于是我们可以写出代价函数:
</div>

```wl
cost[i_]:=Block[
	{P=1,D=1,S=2,V=1,l},
	l=Drop[Divisors[i],-1];
	Join[
		Transpose[{Thread[l->i],S+i/l V}],
		{{i-1->i,P},{i+1->i,D}}
	]
]
```

然后直接遍历整个求解域, 生成有向加权图.

当然因为 Mathematica 不支持多重图, 所以需要手动去重.

```wl
n=100;
raw=Drop[Flatten[Table[cost[i],{i,1,n+10}],1],-1];
{dir,wei}=Transpose[(SortBy[#,Last]&/@GatherBy[raw,First])[[All,1]]];
G=Graph[dir,EdgeWeight->wei,
	PlotTheme->"Monochrome",
	GraphLayout->"CircularEmbedding",
	ImageSize->640
]
Export["FastInput_3.png",G,Background->None,"CompressionLevel"->100];
```

![](../wp-content/uploads/2017/10/fastinput_3.png)

Wow! Cool, 左半边是整数分解产生的分形结构.

于是问题转化为求从节点$0$到节点$i$的最短路.

这就是图论问题了.

```wl
dp[1]=1;
dp[i_]:=dp[i]=With[
	{l=Rest@Reverse@Divisors[i]},
	Min@Append[dp/@l+i/l+2,dp[i-1]+1]
]
acv=If[#==1,0,With[{l=Rest@Reverse@Divisors@#},Min[#0/@l+#/l+2]]]&;
ways=FindShortestPath[G,0,All]/@Range[n];
dis=GraphDistance[G,0,#]&/@Range[n]//Round;
$$Alpha]=a/.FindFit[dis,a Log[x],a,x];
listplot=ListLinePlot[
	{Array[acv,100],Array[dp,100],dis},
	AspectRatio->1/4,PlotTheme->"Web",ImageSize->1280,
	PlotLegends->{"ACV","ACV-E","ACV-ED"}
];
pic4=Show[listplot,Plot[a Log[x]/. {a->$$Alpha]},{x,1,n},PlotStyle->Green]]
Export["FastInput_4.png",pic4,Background->None,"CompressionLevel"-
```

可以看到加入删除操作后在不少点有一定的提升.

总体增长速度下降到了 $4.30628\log n$

![](../wp-content/uploads/2017/10/fastinput_4.png)
 