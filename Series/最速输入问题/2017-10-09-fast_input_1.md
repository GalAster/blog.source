---
title: 最速输入问题(上)
author: Aster
type: post
date: 2017-10-09T14:51:20+00:00
url: /2017/10/fast_input_1/
page_preloader:
  - 'false'
theme_header_style:
  - "1"
theme_header_align:
  - left
theme_toolbar_toggle:
  - 'true'
background_selector_orientation:
  - full_width_layout
body_color_gradient:
  - single
body_color_gradient_style:
  - linear
body_color_gradient_angle:
  - vertical
body_size:
  - 'false'
body_source:
  - no-image
body_parallax:
  - 'false'
page_color_gradient:
  - single
page_color_gradient_style:
  - linear
page_color_gradient_angle:
  - vertical
page_size:
  - 'false'
page_source:
  - no-image
page_parallax:
  - 'false'
header_color_gradient:
  - single
header_color_gradient_style:
  - linear
header_color_gradient_angle:
  - vertical
header_size:
  - 'false'
header_source:
  - no-image
header_parallax:
  - 'false'
banner_color_gradient:
  - single
banner_color_gradient_style:
  - linear
banner_color_gradient_angle:
  - vertical
banner_size:
  - 'false'
banner_source:
  - no-image
banner_parallax:
  - 'false'
footer_color_gradient:
  - single
footer_color_gradient_style:
  - linear
footer_color_gradient_angle:
  - vertical
footer_size:
  - 'false'
footer_source:
  - no-image
footer_parallax:
  - 'false'
categories:
  - CODE➤GEASS
  - 理宅异闻录
\tags: Combinatorics
  - 数学
  - 组合学

---
> 屏幕上有一个字符, 如果只用全选复制粘贴, 要达到$n$个字符最少要多少次按键?

要想达到$N$个字符

  * 如果$N$是个素数,玩完了

只能一个一个复制了, ACVVVVVVVVVV...

也就是 N+2 次.

  * 如果N可以分解

那么我们找出他的一个因子 $\mathrm{i}$ ,另一个因子记为$ \mathrm{ j=N/i}$

也就是达到 $\mathrm{dp[i]}$ 之后粘贴 $j+1$ 次

要不就达到 $\mathrm{dp[j]}$ 之后粘贴$ i+1$ 次

$$\mathtt{dp[i] =Min[dp[j] + i/j + 2, dp[i/j] + j + 2]}$$

我们比较三种路径那个更小就行了.

当然所有路线一起比是一样的...

<!--more-->

<pre class="lang:mathematica decode:true " title="匿名函数递归">If[#==1,0,With[{l=Rest@Reverse@Divisors@#},Min[#0/@l+#/l+2]]]&[10000]</pre>

小tip, 匿函递归, $\mathtt{#0}$表示匿名函数本身.

当然只有复杂度是对数级的时候才可以用, 因为这么写不含记忆化.

当然如果是生成这个序列的话会稍微复杂一些:

<pre class="lang:mathematica decode:true" title="ACV问题">stdp[1]=ConstantArray["V",dp[1]=0];
dp[i_]:=dp[i]=With[{l=Rest@Reverse@Divisors[i]},Min[dp/@l+i/l+2]];
stdp[i_]:=stdp[i]=Block[
    {l=Rest@Reverse@Divisors[i],st},
    st=Take[l,Ordering[dp/@l+i/l+2,1]];
    Join[stdp@@st,{"A","C"},ConstantArray["V",i/First@st]]
];

TableForm[StringJoin@@@stdp/@#,TableHeadings->{#,None}]&[DeleteCases[Range[30],_?PrimeQ]]
pic1=ListLinePlot[dp/@Range[200],
    PlotRange->All,AspectRatio->1/3,
    ImageSize->640,ColorFunction->Hue
]
Export["FastInput_1.png",pic1,Background->None];</pre>

<img class="size-full wp-image-860 aligncenter" src="../wp-content/uploads/2018/01/fastinput_1.png" alt="" width="640" height="223" /> 

---

如果没有初始输入, 但是允许按键输入会怎么样?

那就把$\mathtt{ dp[i-1]}$也加入比较呗.

$$\mathtt{dp[i] =Min[dp[i-1], dp[j] + i/j + 2, dp[i/j] + j + 2]}$$

就是这样复杂度会从对数增加到线性的不好...

<pre class="lang:mathematica decode:true " title="EACV问题">stdp[1]=ConstantArray["E",dp[1]=1];
dp[i_]:=dp[i]=With[
	{l=Rest@Reverse@Divisors[i]},
	Min@Append[dp/@l+i/l+2,dp[i-1]+1]
];
stdp[i_]:=stdp[i]=Block[
	{l=Rest@Reverse@Divisors[i],st},
	st=Ordering[Join[dp/@l+i/l+2,{dp[i-1]+1}],1];
	If[First@st>Length[l],
		Append[stdp[i-1],"E"],
		Join[stdp@@Take[l,st],{"A","C"},ConstantArray["V",i/First@Take[l,st]]]
	]
]

TableForm[StringJoin@@@Array[stdp,20],TableHeadings->{Range[20],None}]
model=NonlinearModelFit[data=Array[dp,1000],a Log[x],a,x];
pic2=Show[
	ListLinePlot[data,
		PlotLegends->Placed[model["ParameterTable"],{0.6,0.15}],
		PlotLabel->y==model["BestFit"]
	],
	Plot[model["BestFit"],{x,0,1000},PlotStyle->Red]
]
Export["FastInput_2.png",pic2,Background->None];</pre>

<img class="size-full wp-image-862 aligncenter" src="../wp-content/uploads/2017/10/fastinput_2.png" alt="" width="360" height="242" /> 

---

如果允许使用鼠标部分选中会不会得到更好的结果呢?

我们下节再来研究...